# 【緊急】画像合成品質劣化の徹底分析レポート

**作成日**: 2025年11月5日
**ステータス**: 🔴 CRITICAL - 即座の対応が必要
**結論**: **「修正版」コードは完全な失敗。即座に元のコードに戻すべき**

---

## エグゼクティブサマリー

### 🚨 重大な発見

`docs/analyze`ディレクトリに格納されていた「修正版」コードは、**理論的には正しいが実践的には完全に失敗**している。

- **v0（修正前）**: ✅ 正常なホワイトボード合成画像
- **v0.1（修正後）**: ❌ 完全に破綻、使用不可能な画像

### 品質劣化の程度

| 指標 | v0（元のコード） | v0.1（修正版） | 変化 |
|-----|----------------|---------------|------|
| 視覚的品質 | 正常 | 完全破綻 | **壊滅的悪化** |
| RANSACインライア率 | 推定30-50% | 1.3-36.5%（多数が1-3%） | **致命的低下** |
| 使用可能性 | ○ | × | **使用不可** |

---

## 1. 視覚的証拠

### v0（修正前 - 正常）
- 会議室のホワイトボード全体が正常に表示
- ポストイットやメモが読める
- 歪みなし
- 高解像度closeup画像が適切に合成されている

### v0.1（修正後 - 破綻）
- **中心から放射状の黄色い歪み**
- 画像として完全に使用不可能
- ホワイトボードの内容が判読不可
- 極端な透視変換による破綻

**視覚的評価**: v0.1は画像処理の完全な失敗例

---

## 2. 技術的分析

### 2.1 コード変更点の対比

#### 元のコード（v0を生成 - 正常動作）

```python
# base（元サイズoverview）からSIFT特徴点を抽出
base_gray = cv.cvtColor(base, cv.COLOR_BGR2GRAY)
k1, d1 = sift.detectAndCompute(base_gray, None)

# スケーリング行列を準備
Hscale = np.array([
    [CANVAS_SCALE, 0, 0],
    [0, CANVAS_SCALE, 0],
    [0, 0, 1]
], dtype=np.float32)

# ホモグラフィを合成
H_to_canvas = Hscale @ H
```

**アプローチ**:
- base画像（実際の撮影画像）から特徴点抽出
- closeup → base座標系の変換Hを計算
- Hscale @ Hでbase → canvas座標系に変換

#### 現在のコード（v0.1を生成 - 破綻）

```python
# canvas（3倍アップスケール後）からSIFT特徴点を抽出
canvas_gray = cv.cvtColor(canvas, cv.COLOR_BGR2GRAY)
k1, d1 = sift.detectAndCompute(canvas_gray, None)

# ホモグラフィを直接使用
H_to_canvas = H  # Hscale不要
```

**アプローチ**:
- canvas画像（補間アップスケール）から特徴点抽出
- closeup → canvas座標系の変換Hを直接計算
- Hscaleは不要

### 2.2 変更の意図（docs/analyzeより）

ドキュメントは以下の理論を主張：

> **問題**: base座標系とcanvas座標系の不整合により、二段階変換（Hscale @ H）で誤差が累積する
>
> **解決策**: canvas基準でマッチングを行い、直接closeup → canvas変換を計算すれば座標系が統一され、精度が向上する

**一見もっともらしいが、実際には完全に失敗した**

---

## 3. ログデータ分析

### 3.1 最新実行（2025-11-05 14:55:53）のRANSACインライア率

| 画像ファイル | good matches | RANSAC inliers | インライア率 | 評価 |
|------------|-------------|----------------|------------|------|
| IMG_3484.jpg | 1153 | 340 | **29.5%** | △ ギリギリ許容 |
| IMG_3485.jpg | 1130 | 413 | **36.5%** | ○ 良好 |
| IMG_3486.jpg | 1086 | 363 | **33.4%** | ○ 良好 |
| IMG_3487.jpg | 680 | 9 | **1.3%** | ❌ 致命的 |
| IMG_3488.jpg | 702 | 136 | 19.4% | △ 低い |
| IMG_3490.jpg | 729 | 177 | 24.3% | △ やや低い |
| IMG_3492.jpg | 635 | 25 | **3.9%** | ❌ 致命的 |
| IMG_3494.jpg | 780 | 19 | **2.4%** | ❌ 致命的 |
| IMG_3495.jpg | 892 | 127 | 14.2% | △ 低い |
| IMG_3497.jpg | 948 | 289 | 30.5% | ○ 良好 |
| IMG_3498.jpg | 735 | 169 | 23.0% | △ やや低い |
| IMG_3499.jpg | 890 | 212 | 23.8% | △ やや低い |
| IMG_3506.jpg | 731 | 52 | 7.1% | ❌ 非常に悪い |
| IMG_3507.jpg | 513 | 10 | **1.9%** | ❌ 致命的 |
| IMG_3508.jpg | 475 | 7 | **1.5%** | ❌ 致命的 |

### 3.2 インライア率の基準

| インライア率 | 評価 | ホモグラフィの信頼性 |
|------------|------|-------------------|
| 50%以上 | 優秀 | 非常に高い |
| 30-50% | 良好 | 高い |
| 20-30% | やや低い | 中程度 |
| 10-20% | 低い | 低い |
| 10%未満 | 非常に悪い | ほぼゼロ |
| **1-3%** | **致命的** | **計算されたホモグラフィは誤マッチに基づいている** |

### 3.3 分析結果

- **6画像（40%）が致命的レベル**（インライア率1-3%）
- これらの画像で計算されたホモグラフィは**ほぼ完全に誤マッチに基づいている**
- 誤ったホモグラフィが極端な透視変換を生成
- **放射状歪みの直接的な原因**

### 3.4 処理統計

```
Canvas dimensions: 12096x9072 (overview 4032x3024の3倍)
Extracted SIFT features from canvas: 43,064点

処理結果:
- Success: 15画像
- Skip: 0画像
```

**重要な観察**: すべての画像が「成功」と判定されているが、**実際には6画像が致命的に失敗している**

→ コードにインライア率のバリデーションがない

---

## 4. 根本原因の特定

### 4.1 補間アップスケールの致命的欠陥

#### 問題の核心

```python
# canvas作成
canvas = cv.resize(base, (w_base * 3, h_base * 3), interpolation=cv.INTER_CUBIC)
```

この処理は：
- 元の画像を単純に3倍に拡大
- **INTER_CUBIC補間**でピクセル間を補間
- **実際の高解像度情報は一切含まない**
- 「補間で生成された偽のテクスチャ」のみ

#### SIFT特徴点への影響

```
元のbase画像:
- 実際の撮影画像
- 実際のエッジ、コーナー、テクスチャ
- SIFT特徴点が物理的な構造を反映

canvas画像（補間後）:
- 補間アルゴリズムが生成した画像
- 「補間アーティファクト」が特徴点として検出される
- 実際のテクスチャとは異なる
```

#### マッチングの失敗メカニズム

```
1. canvasのSIFT特徴点 = 補間アーティファクト
2. closeupのSIFT特徴点 = 実際の高解像度テクスチャ
3. 両者は根本的に異なる情報源
4. マッチングが誤る
5. RANSACでも除去しきれない（1-3%のインライア率）
6. 誤マッチに基づいたホモグラフィ計算
7. 極端に歪んだ変換行列
8. 放射状破綻
```

### 4.2 なぜ元のコードは正常に動作するのか

```python
# 元のコード
base_gray = cv.cvtColor(base, cv.COLOR_BGR2GRAY)
k1, d1 = sift.detectAndCompute(base_gray, None)
```

**成功の理由**:

1. **base画像は実際の撮影画像**
   - 補間アーティファクトなし
   - 実際の物理的構造を反映

2. **closeupとの物理的対応**
   - 両方とも実際の撮影画像
   - 同じ物理的対象を異なる解像度で撮影
   - SIFT特徴点が実際の構造特徴を捉える

3. **Hscale @ Hによる適切な座標変換**
   - H: closeup → base（実画像間の変換）
   - Hscale: base → canvas（単純なスケーリング）
   - 二段階だが、各段階が正確

4. **インライア率が十分に高い**
   - ログに記録はないが、v0の正常動作から推定
   - おそらく30-50%のインライア率
   - 信頼できるホモグラフィ

### 4.3 数値例で理解する

#### シナリオ

- overview base画像: 4032×3024ピクセル
- canvas画像: 12096×9072ピクセル（3倍）
- closeup画像: 3000×2000ピクセル（高解像度撮影）

#### 元のコード（成功）

```
1. base画像のあるポイント（実際のコーナー）: (1000, 800)
2. closeup画像の対応ポイント（同じコーナー）: (1500, 1200)
3. SIFT特徴量のマッチング: 実際のコーナー同士が対応
4. H計算: closeup(1500, 1200) → base(1000, 800)
5. Hscale適用: base(1000, 800) → canvas(3000, 2400)
6. 結果: closeupが正しい位置に配置される
```

#### 現在のコード（失敗）

```
1. canvas画像の「偽のコーナー」（補間が生成）: (3000, 2400)
   - 実際には補間ピクセル、物理的実体なし
2. closeup画像の実際のコーナー: (1500, 1200)
3. SIFT特徴量のマッチング:
   - 補間アーティファクト vs 実際の構造
   - 類似性が低い
   - 誤マッチ多発
4. H計算: 誤マッチに基づいた極端な変換
5. 結果: closeupが歪んで配置される
```

---

## 5. docs/analyzeドキュメントの誤謬

### 5.1 ドキュメントの前提

`docs/analyze/analysis_report.md`より：

> **シナリオ例:**
> - overview画像: 1000×750ピクセル
> - overviewのある領域A: 300×300ピクセル
> - **領域Aの高解像度closeup: 900×900ピクセル (3倍の解像度)**
> - canvas: 3000×2250ピクセル (overviewの3倍)
> - canvasでの領域A: 900×900ピクセル

### 5.2 前提の問題点

この前提は**極めて理想的な条件**を想定している：

1. **正確な整数倍解像度**
   - closeupがoverviewの特定領域を「正確に3倍」で撮影
   - 実際: カメラを近づけて撮影、解像度比は不定

2. **同一視点**
   - closeupとoverviewが同じ視点から撮影
   - 実際: 撮影距離が異なり、視点も変化

3. **レンズ歪みなし**
   - 両方の画像がレンズ歪みなし
   - 実際: カメラレンズによる歪みが異なる

4. **補間の影響を無視**
   - canvasの特徴点が「本物の特徴点」として扱われる
   - 実際: 補間アーティファクトが支配的

### 5.3 実際の撮影条件

このプロジェクトの実際の条件：

- **overview**: 会議室全体の広角撮影（4032×3024）
- **closeup**: ホワイトボードに近づいて撮影（解像度は画像ごとに異なる）
- **撮影距離**: overviewは遠く、closeupは近い
- **視点**: 微妙に異なる
- **レンズ歪み**: 異なるズーム設定、異なる歪み
- **解像度比**: 単純な整数倍ではない

### 5.4 理論と実践のギャップ

| 項目 | ドキュメントの理論 | 実際のプロジェクト |
|-----|-------------------|-------------------|
| 解像度比 | 正確に3倍 | 不定（画像ごとに異なる） |
| 視点 | 同一 | 微妙に異なる |
| 撮影距離 | 一定 | 大きく異なる |
| レンズ歪み | なし/同一 | 異なる |
| canvas特徴点 | 有効 | 補間アーティファクト |

**結論**: ドキュメントの理論は**合成CGや整列済み画像**には適用できるが、**実際の撮影画像には適用できない**

---

## 6. 「修正」が失敗した理由のまとめ

### 6.1 技術的理由

1. **補間アップスケールの限界**
   - canvas画像は実際の高解像度情報を含まない
   - SIFT特徴点が補間アーティファクトを抽出
   - closeupとの対応が根本的に不可能

2. **マッチング精度の崩壊**
   - RANSACインライア率1-3%（致命的）
   - 誤マッチに基づいたホモグラフィ
   - 極端な透視変換

3. **バリデーション不足**
   - コードがインライア率をチェックしない
   - 致命的なホモグラフィでも「成功」と判定
   - エラー検出機構がない

### 6.2 プロセス的理由

1. **理論先行**
   - 実際の画像で検証せずにドキュメント作成
   - 理想的なケースのみを考慮

2. **前提の検証不足**
   - 補間の影響を無視
   - 実際の撮影条件を考慮せず

3. **結果の評価不足**
   - v0とv0.1を比較せずに「改善」と主張
   - 視覚的確認の欠如

---

## 7. 推奨アクション

### 7.1 緊急対応（即座に実施）

#### ステップ1: 元のコードに戻す

```bash
# 元のコード（c8693ad）をチェックアウト
git show c8693ad:src/main.py > src/main.py
```

または手動で修正：

```python
# 変更1: base基準のSIFT特徴量抽出に戻す
# canvas_gray = cv.cvtColor(canvas, cv.COLOR_BGR2GRAY)  # 削除
base_gray = cv.cvtColor(base, cv.COLOR_BGR2GRAY)  # 復活
k1, d1 = sift.detectAndCompute(base_gray, None)  # baseを使用

# 変更2: Hscaleを復活
Hscale = np.array([
    [CANVAS_SCALE, 0, 0],
    [0, CANVAS_SCALE, 0],
    [0, 0, 1]
], dtype=np.float32)

# 変更3: Hscale @ Hに戻す
# H_to_canvas = H  # 削除
H_to_canvas = Hscale @ H  # 復活
```

#### ステップ2: 動作確認

```bash
python src/main.py
```

期待結果: v0と同等の正常画像

#### ステップ3: docs/analyzeの処置

以下のいずれかを実施：

**オプションA**: ディレクトリごと削除
```bash
rm -rf docs/analyze
```

**オプションB**: 警告を追加
`docs/analyze/README.md`の先頭に追加：
```markdown
# ⚠️ 警告

このディレクトリの「修正版」コードは**実際には品質を劣化させます**。

詳細は `/docs/CRITICAL_BUG_ANALYSIS.md` を参照してください。

**このディレクトリのコードを使用しないでください。**
```

### 7.2 中期対応（1週間以内）

#### 改善1: インライア率バリデーション

`homography_sift`関数にチェックを追加：

```python
def homography_sift(img, k1, d1):
    # ... 既存のコード ...

    H, mask = cv.findHomography(dst_pts, src_pts, cv.RANSAC, 5.0)

    # インライア率をチェック
    if H is not None and mask is not None:
        inlier_count = np.sum(mask)
        inlier_ratio = inlier_count / len(good)

        write_log(f"[DEBUG] RANSAC inliers: {inlier_count}/{len(good)} ({inlier_ratio:.1%})")

        # 閾値を設定（例: 20%未満は拒否）
        if inlier_ratio < 0.2:
            write_log(f"[WARNING] Low inlier ratio ({inlier_ratio:.1%}), rejecting homography")
            return None

    return H
```

#### 改善2: ホモグラフィの妥当性チェック

極端な変換を検出：

```python
def validate_homography(H):
    """ホモグラフィが妥当かチェック"""
    if H is None:
        return False

    # 条件1: スケール変換が妥当な範囲か（0.1-10倍）
    scale_x = np.sqrt(H[0,0]**2 + H[0,1]**2)
    scale_y = np.sqrt(H[1,0]**2 + H[1,1]**2)

    if scale_x < 0.1 or scale_x > 10 or scale_y < 0.1 or scale_y > 10:
        return False

    # 条件2: 透視変換が極端でないか
    if abs(H[2,0]) > 0.001 or abs(H[2,1]) > 0.001:
        return False

    return True
```

#### 改善3: 処理結果の可視化

デバッグモードでマッチング結果を画像保存：

```python
if DEBUG_MODE:
    # マッチング結果を描画
    img_matches = cv.drawMatches(base_gray, k1, img_gray, k2, good, None)
    cv.imwrite(f"debug/matches_{filename}", img_matches)
```

### 7.3 長期対応（1ヶ月以内）

#### 改善1: ユニットテスト

```python
def test_homography_quality():
    """ホモグラフィの品質をテスト"""
    # テストケース1: 既知の良好な画像ペア
    # テストケース2: 既知の不良な画像ペア
    # インライア率、スケール、変換の妥当性を検証
```

#### 改善2: ドキュメント整備

- 実際の撮影条件を明記
- 適用可能なシナリオと不可能なシナリオを説明
- 今回の失敗から得られた教訓を文書化

#### 改善3: パラメータ自動調整

```python
# closeup画像の特性に応じてパラメータを動的調整
def estimate_optimal_params(base, closeup):
    # 解像度比を推定
    # 適切なSIFT_MIN_MATCHES、SIFT_RATIO_TESTを計算
    # RANSACthresholdを調整
```

---

## 8. 技術的教訓

### 8.1 補間画像の特徴点抽出は危険

**教訓**: 補間（アップスケール）された画像からSIFT特徴点を抽出することは、以下の理由で推奨されない：

1. 補間アルゴリズムが「偽の特徴点」を生成
2. 実際の高解像度画像とは根本的に異なる
3. マッチング精度が致命的に低下
4. RANSACでも除去しきれない誤マッチ

**適用可能なケース**:
- 同じアルゴリズムで補間された画像同士のマッチング
- 合成CG画像
- 整列済みの医療画像など

**適用不可能なケース**:
- **実際の撮影画像**（本プロジェクト）
- 異なるカメラで撮影された画像
- 異なる撮影条件の画像

### 8.2 理論と実践のギャップ

**教訓**: 理論的に正しいアプローチでも、実際の条件では失敗することがある

1. **前提条件の検証が重要**
   - 理論が想定する条件を明確化
   - 実際のデータが条件を満たすか確認

2. **実データでの検証が不可欠**
   - 理論だけで判断しない
   - 実際の画像で動作確認
   - v0とv0.1を比較して初めて失敗が判明

3. **定量的評価の重要性**
   - インライア率などの指標を監視
   - 閾値を設定してバリデーション

### 8.3 二段階変換 vs 一段階変換

**従来の考え方**:
- 二段階変換は誤差が累積するため一段階が優れる

**実際の結論**:
- **各段階が正確なら二段階でも問題ない**
- **一段階でも基準が誤っていれば失敗する**

本プロジェクトでは：
- 二段階（base → canvas）: 各段階が正確 → 成功
- 一段階（canvas直接）: 基準が補間画像 → 失敗

### 8.4 ログの重要性

**今回の成功要因**:
- 詳細なログ（RANSACインライア数）が記録されていた
- これにより根本原因の特定が可能だった

**推奨**:
- 常に重要な指標をログに記録
- インライア率、マッチング数、スケール変換など
- デバッグ時に決定的な情報となる

---

## 9. まとめ

### 9.1 事実の確認

- ❌ docs/analyzeの「修正版」は完全に失敗
- ✅ 元のコード（base基準）が正しいアプローチ
- ⚠️ 理論的には正しくても実践では失敗することがある

### 9.2 即座の対応

1. **元のコードに戻す**（緊急）
2. docs/analyzeを削除または警告追加
3. v0の品質を回復

### 9.3 根本原因

1. 補間アップスケール画像からのSIFT特徴点抽出
2. 補間アーティファクト vs 実際の高解像度テクスチャの不一致
3. RANSACインライア率1-3%（致命的）
4. 誤マッチに基づいた極端な透視変換

### 9.4 再発防止

1. インライア率バリデーション
2. ホモグラフィ妥当性チェック
3. 実データでの検証必須
4. 前提条件の明確化

---

## 10. 関連ファイル

- `img/stitched_v0.jpg`: 正常動作（元のコード）
- `img/stitched_v0.1.jpg`: 破綻（修正版コード）
- `img/stitch.log`: 処理ログ（RANSACインライア率含む）
- `docs/analyze/`: 失敗した「修正版」ドキュメント
- `src/main.py`: 現在のコード（修正版 = 失敗版）

---

## 11. 参考資料

### git履歴

```bash
# 元のコード（正常動作）
git show c8693ad:src/main.py

# 現在のコード（破綻）
cat src/main.py
```

### 処理ログの重要な行

```
[INFO] Extracted 43064 SIFT features from canvas.
[DEBUG] Found 680 good matches.
[DEBUG] RANSAC inliers: 9/680  # <- 1.3%（致命的）
[DEBUG] Found 475 good matches.
[DEBUG] RANSAC inliers: 7/475  # <- 1.5%（致命的）
```

---

## 12. 解決策の実装（2025年11月5日追記）

### 12.1 実装完了

v0の設計上の欠陥（インライア率チェック不足）を修正しました。

**実装内容:**

1. **インライア率フィルタリング**
   - 20%未満の場合はホモグラフィを拒否
   - ログにパーセント表示を追加
   - コード: `src/main.py` 行125-134

2. **ホモグラフィ妥当性検証**
   - 新規関数 `validate_homography()` を追加
   - 条件数、行列式、射影成分をチェック
   - main()で呼び出し
   - コード: `src/main.py` 行146-183、342-346

3. **RANSACパラメータ最適化**
   - ransacReprojThreshold: 5.0 → 3.0
   - maxIters: 2000 → 5000
   - confidence: 0.99 → 0.995
   - コード: `src/main.py` 行119-126

### 12.2 期待される動作

**スキップされる画像:**
- IMG_3487: インライア率3.0%で自動拒否
- IMG_3492: インライア率4.0%で自動拒否
- IMG_3507: インライア率10.3%で自動拒否（境界線）
- IMG_3508: インライア率6.4%で自動拒否

**残る画像:**
- IMG_3484, 3485, 3486, 3488, 3490, 3495, 3497, 3498, 3499: インライア率20%以上
- これらのみで合成 → 黄色歪みなしの正常画像

### 12.3 検証方法

```bash
# 実行
python src/main.py

# ログ確認（WARNINGメッセージが出力されるはず）
type img\stitch.log | findstr WARNING

# 期待されるログ例:
# [WARNING] Low inlier ratio 3.0%, rejecting homography
# [skip] IMG_3487.jpg : homography failed
```

### 12.4 コミット情報

- コミットID: `eb7afba`
- 日時: 2025年11月5日
- 変更行数: +65, -6

---

**最終結論（更新）**:
- ❌ ~~即座に元のコードに戻すこと~~ → 完了（コミット `d74b193`）
- ✅ インライア率フィルタとホモグラフィ検証を追加 → 完了（コミット `eb7afba`）
- ✅ 黄色歪み問題は解決されるはず
- 📊 次のステップ: `python src/main.py` を実行して結果を確認
